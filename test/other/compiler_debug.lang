import "std/memory"
import "std/String"
import "std/Array"
import "std/print"

function hash(this: String*): u64 {
    // Fowler–Noll–Vo hash function
    let h: u64 = 14695981039346656037u64; // FNV_offset_basis
    for (let i = 0u64; i < .length; ++i) {
        h = h ^ .ptr[i];
        h = h * 1099511628211u64; // FNV_prime
    }
    return h;
}

type HashTableBucket<KeyType, ValueType> {
    let used: bool = false;
let key: KeyType;
let value: ValueType;
}

function HashTableBucket<KeyType, ValueType>(key: KeyType, value: ValueType) {
    let r: HashTableBucket<KeyType, ValueType>;
    r.used = true;
    r.key = key;
    r.value = value;
    return r;
}

type HashTable<KeyType, ValueType> {
	let buckets: Array<HashTableBucket<KeyType, ValueType>>;
let size: u64 = 0;
}


function set<KeyType, ValueType>(this: HashTable<KeyType, ValueType>*, key: KeyType, value: ValueType): void {
    let target_size: u64 = max(32u64, .buckets.length);
    if (.size > 0.5 * .buckets.length) target_size = 2u64 * target_size;
    if (.buckets.length < target_size)
        .buckets.resize(target_size);
    const h: u64 = key.hash(); // FIXME: Doesn't compile, we need to delay type checking here.
    const index = h % .buckets.length;
    // TODO: Handle collisions
	.buckets.set(index, HashTableBucket(key, value));
    ++.size;
}

function get<KeyType, ValueType>(this: HashTable<KeyType, ValueType>*, key: KeyType): ValueType {
    const h = key.hash();
    const index = h % .buckets.length;
    // TODO: Handle collisions
    return .buckets.get(index).value;
}

function main() {
    let hash_table: HashTable<String, i32>;
    const key = String("MyKey");
    hash_table.set(key, 1337);
    let v = hash_table.get(key);
    print(key);
    printf(": %u\n", v);
    return 0;
}
