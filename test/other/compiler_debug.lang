import "std/memory"

type Array<T> {
	let capacity : u64 = 0;
	let length : u64 = 0;
	let data : T* = null_pointer();
}

function reserve<T>(this: Array<T>*, size: u64) : void {
	if(size <= .capacity)
		return;
	
	// FIXME: Yeah, we don't have "sizeof" yet. Will this be part of the reflection system? 'T.byte_size()' ? :O
	// let ptr : T* = malloc(size * sizeof(T));
	let ptr : T* = malloc(size * 64);
	
	for(let idx : u64 = 0; idx < .length; ++idx) {
		ptr[idx] = .data[idx];
	}
	if(.capacity > 0)
		free(.data);
	
	.capacity = size;
	.data = ptr;
}

function push_back<T>(this: Array<T>*, value: T) : u64 {
	if(.capacity <= .length) 
		.reserve((.capacity + 1) * 2);
	
	.data[.length] = value;
	++.length;
	return .length;
}

function get<T>(this: Array<T>*, index: u64) : T {
	return .data[index];
}

function dump<T>(this: Array<T>*) : void {
	printf("----------------\n");
	for(let idx : u64 = 0; idx < .length; ++idx) {
		printf("  a[%d] = %d\n", idx, .get(idx));
	}
}

function destructor<T>(this: Array<T>*) : void {
	.dump();
	free(.data);
	.length = 0;
	.capacity = 0;
}

function test() : Array<u64> {
	let arr : Array<u64>;
	
	const forty_two : u64 = 42; // Forced Cast, otherwise the we can't resolve the function, yet.
	const leet : u64 = 1337;
	arr.push_back(forty_two);
	arr.push_back(leet);
	arr.dump();
	arr.push_back(forty_two);
	arr.push_back(leet);
	arr.dump();

	return arr;
}

function main() {
	let t = test();
	t.dump();
	return t.length;
}
